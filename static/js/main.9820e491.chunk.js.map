{"version":3,"sources":["view/Card.react.js","model/Deck.js","view/Deck.react.js","core-error/invariant.js","view/AddRemoveCardBtn.react.js","App.js","serviceWorker.js","index.js"],"names":["CardView","card","contentType","getContentType","className","getVisibleSide","Error","Flashcard","data","this","_data","currentSide","sides","length","perspective","FlashcardDeck","cards","_cardIndex","_cards","advance","ret","_copy","isStartingSide","splice","push","emptyDeckCard","concat","JSON","stringify","DeckView","deck","onDeckChange","onDeckClicked","useCallback","top","onClick","invariant","condition","message","newCardNum","AddRemoveCardBtn","intialDeck","onRemove","onAdd","onAddClick","addCard","onRemoveClick","deleteTopCard","classNames","symbol","persistedCards","localStorage","getItem","parse","e","App","useState","setDeck","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9820e491.chunk.js","sourcesContent":["import React from \"react\";\nimport type Flashcard from \"../model/Deck\";\nimport \"./Card.css\";\n\ntype Props = $ReadOnly<{| card: Flashcard |}>;\n\nfunction CardView({ card }: Props) {\n  // Enable editing of a card when someone double taps into it\n  const contentType = card.getContentType();\n\n  switch (contentType) {\n    case \"text\":\n    case \"emptyDeckMessage\":\n    case \"cardCreator\":\n      return <div className=\"Card\">{card.getVisibleSide(\"normal\")}</div>;\n    default:\n      throw new Error(\"Unhandled type \" + contentType);\n  }\n}\n\nexport default CardView;\n","// TODO: do a more \"strut.io like\" model and allow\n// a card to be composed of components, each with a content type?\nexport type SerializedFlashcard = $ReadOnly<\n  | {\n      contentType: \"text\",\n      sides: $ReadOnlyArray<string>,\n      currentSide: number\n    }\n  | {\n      contentType: \"emptyDeckMessage\",\n      sides: [string, string],\n      currentSide: number\n    }\n>;\n\ntype Perspective = \"normal\" | \"flipped\";\n\nexport class Flashcard {\n  constructor(data: SerializedFlashcard) {\n    this._data = data;\n  }\n\n  advance(): Flashcard {\n    const data = { ...this._data };\n    data.currentSide = (data.currentSide + 1) % data.sides.length;\n    return new Flashcard(data);\n  }\n\n  getVisibleSide(perspective: Perspective): string {\n    return this._data.sides[\n      perspective === \"normal\"\n        ? this._data.currentSide\n        : this._data.sides.length - 1 - this._data.currentSide\n    ];\n  }\n\n  getContentType(): string {\n    return this._data.contentType;\n  }\n\n  isStartingSide(): boolean {\n    return this._data.currentSide === 0;\n  }\n}\n\n// Don't think of the deck class as simply representing a deck of cards.\n// It represents the game rules too. Maybe this would better be called\n// \"game\"?\nexport default class FlashcardDeck {\n  _cards: $ReadOnlyArray<Flashcard>;\n  _cardIndex = 0;\n\n  constructor(cards: $ReadOnlyArray<Flashcard>) {\n    this._cards = cards;\n  }\n\n  cards(): $ReadOnlyArray<Flashcard> {\n    return this._cards;\n  }\n\n  advance(): FlashcardDeck {\n    const card = this._cards[this._cardIndex].advance();\n\n    // duplicate the record since all data should be immutable.\n    // TODO: language support for easier duplication?\n    // TODO: immutable.js for data structures?\n    const ret = this._copy();\n    ret._cards[ret._cardIndex] = card;\n\n    // The card has been flipped back to its initial state\n    // advance to the next card.\n    if (card.isStartingSide()) {\n      ret._cardIndex = (ret._cardIndex + 1) % ret._cards.length;\n    }\n\n    return ret;\n  }\n\n  // TODO: this class needs to be generic so `addCard` can take the\n  // appropriately typed card for the given game.\n  // The card making view will differ per game type as each game type\n  // requires different card parameters.\n  addCard(card: Flashcard): FlashcardDeck {\n    const ret = this._copy();\n\n    ret._cards.splice(this._cardIndex, 0, card);\n    return ret;\n  }\n\n  deleteTopCard(): FlashcardDeck {\n    const ret = this._copy();\n    ret._cards.splice(this._cardIndex, 1);\n    if (ret._cards.length === 0) {\n      ret._cards.push(emptyDeckCard());\n    }\n\n    return ret;\n  }\n\n  _copy(): FlashcardDeck {\n    const ret = new FlashcardDeck(this._cards.concat());\n    ret._cardIndex = this._cardIndex;\n    return ret;\n  }\n\n  top(): Flashcard {\n    return this._cards[this._cardIndex];\n  }\n\n  stringify(): string {\n    return JSON.stringify(this);\n  }\n}\n\nexport function emptyDeckCard(): Flashcard {\n  return new Flashcard({\n    contentType: \"emptyDeckMessage\",\n    sides: [\"You have no cards in your deck.\", \"Create Cards\"],\n    currentSide: 0\n  });\n}\n","import React, { useCallback } from \"react\";\nimport Card from \"./Card.react\";\n\nimport Deck from \"../model/Deck\";\n\ntype Props = $ReadOnly<{|\n  deck: Deck,\n  onDeckChange: Deck => void\n|}>;\n\nfunction DeckView({ deck, onDeckChange }: Props) {\n  const onDeckClicked = useCallback(() => {\n    onDeckChange(deck.advance());\n  }, [deck, onDeckChange]);\n\n  const card = deck.top();\n  return (\n    <div onClick={onDeckClicked}>\n      <Card card={card} />\n    </div>\n  );\n}\n\nexport default DeckView;\n","export default function invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","import React, { useCallback } from \"react\";\nimport \"./AddRemoveCardBtn.css\";\nimport invariant from \"../core-error/invariant\";\nimport FlashcardDeck, { Flashcard } from \"../model/Deck\";\n\ntype Props = $ReadOnly<{|\n  deck: FlashcardDeck,\n  onRemove: () => void,\n  onAdd: () => void\n|}>;\n\nlet newCardNum = 0;\nfunction AddRemoveCardBtn({ deck, onRemove, onAdd }: Props) {\n  invariant(\n    onRemove == null || onAdd == null,\n    \"You cannot specify both onAdd and onRemove\"\n  );\n  invariant(\n    !(onRemove == null && onAdd == null),\n    \"You must specify either onAdd or onRemove\"\n  );\n\n  const onAddClick = useCallback(() => {\n    ++newCardNum;\n    onAdd(\n      deck.addCard(\n        new Flashcard({\n          contentType: \"text\",\n          sides: [\n            \"New Card (\" + newCardNum + \") Front\",\n            \"New Card (\" + newCardNum + \") Back\"\n          ],\n          currentSide: 0\n        })\n      )\n    );\n  }, [deck, onAdd]);\n  const onRemoveClick = useCallback(() => {\n    onRemove(deck.deleteTopCard());\n  }, [deck, onRemove]);\n  const onClick = onRemove ? onRemoveClick : onAddClick;\n\n  let classNames = \"AddRemoveCardBtn\";\n  let symbol = \"+\";\n  if (onRemove) {\n    classNames += \" remove\";\n    symbol = \"-\";\n  }\n  return (\n    <span className={classNames} onClick={onClick}>\n      {symbol}\n    </span>\n  );\n}\n\nexport default AddRemoveCardBtn;\n","import React, { useState, useCallback } from \"react\";\nimport DeckView from \"./view/Deck.react\";\nimport AddRemoveCardBtn from \"./view/AddRemoveCardBtn.react\";\nimport FlashcardDeck, { NewFlashcardDeck, emptyDeckCard } from \"./model/Deck\";\nimport \"./App.css\";\n\nconst persistedCards = localStorage.getItem(\"flashcards\");\nlet intialDeck;\n\ntry {\n  const cards = JSON.parse(persistedCards);\n  if (cards) {\n    intialDeck = new FlashcardDeck(cards);\n  } else {\n    throw new Error(\"No persisted cards\");\n  }\n} catch (e) {\n  // make a new deck instance\n  intialDeck = new FlashcardDeck([emptyDeckCard()]);\n}\n\nfunction App() {\n  const [deck, setDeck] = useState(intialDeck);\n\n  const onDeckChange = useCallback(deck => {\n    setDeck(deck);\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <DeckView deck={deck} onDeckChange={onDeckChange} />\n      <AddRemoveCardBtn deck={deck} onAdd={onDeckChange} />\n      <AddRemoveCardBtn deck={deck} onRemove={onDeckChange} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}